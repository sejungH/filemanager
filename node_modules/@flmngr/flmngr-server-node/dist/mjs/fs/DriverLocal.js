import * as fs from "fs";
import fsExtra from "fs-extra";
import * as pathUtils from "path";
import { MessageException } from "../lib/MessageException";
import { Message } from "../model/Message";
import { Utils } from "../lib/Utils";
export class DriverLocal {
    constructor(dir, isCacheDriver = false) {
        this.dir = dir;
        this.isCacheDriver = isCacheDriver;
        this.dir = dir.replace(/\/+$/, '');
        this.makeRootDir();
        try {
            fs.accessSync(this.dir, fs.constants.R_OK);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException(Message.createMessage(this.isCacheDriver, Message.FM_DIR_IS_NOT_READABLE, this.dir, null, null, e));
            }
        }
        try {
            fs.accessSync(this.dir, fs.constants.W_OK);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException(Message.createMessage(this.isCacheDriver, Message.FM_DIR_IS_NOT_WRITABLE, this.dir, null, null, e));
            }
        }
    }
    setDriverCache(driverCache) {
        this.driverCache = driverCache;
    }
    getDriverName() {
        return "Local";
    }
    getDir() {
        return this.dir;
    }
    size(path) {
        let stats = fs.statSync(this.dir + path);
        return stats.size;
    }
    lastModified(path) {
        let stats = fs.statSync(this.dir + path);
        return stats.mtimeMs;
    }
    makeDirectory(path) {
        if (fs.existsSync(this.dir + path)) {
            let stats = fs.statSync(this.dir + path);
            if (stats.isDirectory())
                return;
        }
        try {
            fs.mkdirSync(this.dir + path, {
                mode: 0o777,
                recursive: true
            });
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException(Message.createMessage(this.isCacheDriver, Message.FM_UNABLE_TO_CREATE_DIRECTORY, path, null, null, e));
            }
        }
    }
    getRootDirName() {
        let i = this.dir.lastIndexOf("/");
        if (i === -1) {
            return this.dir;
        }
        return this.dir.substr(i + 1);
    }
    makeRootDir() {
        if (!this.directoryExists("")) {
            this.makeDirectory("");
        }
    }
    allDirectories(dirFrom, maxDepth) {
        let dirs = [];
        let fDir = this.dir + dirFrom;
        if (!fs.existsSync(fDir) ||
            !fs.statSync(fDir).isDirectory()) {
            throw new MessageException(Message.createMessage(this.isCacheDriver, Message.FM_ROOT_DIR_DOES_NOT_EXIST));
        }
        let hideDirs = [".cache"];
        let path = "";
        if (dirFrom !== "") {
            path = (pathUtils.basename(this.dir) + '/' + pathUtils.dirname(dirFrom).replace(/\/$/, '')).replace(/\/$/, '');
        }
        this.getDirs__fill(dirs, fDir, hideDirs, path, 0, maxDepth);
        return dirs;
    }
    getDirs__fill(dirs, fDir, hideDirs, path, currDepth, maxDepth) {
        let i = fDir.lastIndexOf("/");
        let dirName;
        if (i > -1) {
            dirName = fDir.substr(i + 1);
        }
        else {
            dirName = fDir;
        }
        dirs.push((path.length > 0 ? ("/" + path) : '') + "/" + dirName);
        let rawDirs;
        try {
            rawDirs = fs.readdirSync(fDir, {
                withFileTypes: true
            }).filter(dirent => dirent.isDirectory()).map(dirent => dirent.name);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException(Message.createMessage(this.isCacheDriver, Message.FM_UNABLE_TO_LIST_CHILDREN_IN_DIRECTORY, path, null, null, e));
            }
        }
        for (let dir of rawDirs) {
            dir = dir.replace(fDir + "/", "");
            let isHide = false;
            for (let j = 0; j < hideDirs.length && !isHide; j++) {
                isHide = isHide || Utils.fmmatch(hideDirs[j], dir, false);
            }
            if (fs.statSync(fDir + "/" + dir).isDirectory() && !isHide && currDepth < Math.min(maxDepth, DriverLocal.MAX_DEPTH)) {
                this.getDirs__fill(dirs, fDir + "/" + dir, hideDirs, path + (path.length > 0 ? "/" : "") + dirName, currDepth + 1, maxDepth);
            }
        }
    }
    directories(path) {
        let dirs = [];
        let rawDirs;
        try {
            rawDirs = fs.readdirSync(this.dir + path, {
                withFileTypes: true
            }).filter(dirent => dirent.isDirectory()).map(dirent => dirent.name);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException(Message.createMessage(this.isCacheDriver, Message.FM_UNABLE_TO_LIST_CHILDREN_IN_DIRECTORY, path, null, null, e));
            }
        }
        for (const dir of rawDirs) {
            dirs.push(dir.replace(this.dir + path + "/", ""));
        }
        return dirs;
    }
    files(path) {
        let rawFiles;
        try {
            rawFiles = fs.readdirSync(this.dir + path, {
                withFileTypes: true
            }).filter(dirent => !dirent.isDirectory()).map(dirent => dirent.name);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException(Message.createMessage(this.isCacheDriver, Message.FM_UNABLE_TO_LIST_CHILDREN_IN_DIRECTORY, path, null, null, e));
            }
        }
        let files = [];
        for (const file of rawFiles) {
            let isFile = false;
            try {
                isFile = fs.statSync(this.dir + path + "/" + file).isFile();
            }
            catch (e) {
            }
            if (isFile) {
                let filename = pathUtils.basename(file);
                files.push({
                    name: filename,
                    mtime: this.lastModified(path + "/" + filename),
                    size: this.size(path + "/" + filename)
                });
            }
        }
        return files;
    }
    move(path, newName) {
        try {
            fs.renameSync(this.dir + path, this.dir + newName);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException(Message.createMessage(this.isCacheDriver, Message.FM_UNABLE_TO_RENAME, null, null, null, e));
            }
        }
    }
    getMimeType(path) {
        return Utils.getMimeType(this.dir + path);
    }
    exists(path) {
        return fs.existsSync(this.dir + path);
    }
    directoryExists(path) {
        return fs.existsSync(this.dir + path) && fs.statSync(this.dir + path).isDirectory();
    }
    fileExists(path) {
        return fs.existsSync(this.dir + path) && fs.statSync(this.dir + path).isFile();
    }
    get(path) {
        return fs.readFileSync(this.dir + path);
    }
    put(path, contents) {
        this.makeDirectory(pathUtils.dirname(path));
        fs.writeFileSync(this.dir + path, contents);
    }
    delete(path) {
        if (this.fileExists(path)) {
            try {
                fs.unlinkSync(this.dir + path);
            }
            catch (e) {
                if (e instanceof Error) {
                    throw new MessageException(Message.createMessage(this.isCacheDriver, Message.UNABLE_TO_DELETE_FILE, path, null, null, e));
                }
            }
        }
        else if (this.directoryExists(path)) {
            try {
                this.deleteFolderRecursiveSync(this.dir + path);
            }
            catch (e) {
                if (e instanceof Error) {
                    throw new MessageException(Message.createMessage(this.isCacheDriver, Message.FM_UNABLE_TO_DELETE_DIRECTORY, null, null, null, e));
                }
            }
        }
    }
    deleteFolderRecursiveSync(directoryPath) {
        if (fs.existsSync(directoryPath)) {
            fs.readdirSync(directoryPath).forEach((file, index) => {
                const curPath = pathUtils.join(directoryPath, file);
                if (fs.lstatSync(curPath).isDirectory()) {
                    this.deleteFolderRecursiveSync(curPath);
                }
                else {
                    fs.unlinkSync(curPath);
                }
            });
            fs.rmdirSync(directoryPath);
        }
    }
    ;
    readStream(path) {
        return fs.createReadStream(this.dir + path);
    }
    copyFile(pathSrc, pathDst) {
        try {
            fs.copyFileSync(this.dir + pathSrc, this.dir + pathDst);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException(Message.createMessage(this.isCacheDriver, Message.FM_ERROR_ON_COPYING_FILES));
            }
        }
    }
    copyDirectory(src, dst) {
        try {
            fsExtra.copySync(this.dir + src, this.dir + dst);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException(Message.createMessage(this.isCacheDriver, Message.FM_ERROR_ON_COPYING_FILES, null, null, null, e));
            }
        }
    }
    uploadFile__getName(fileName, dir, isOverwrite) {
        let name = null;
        if (isOverwrite) {
            if (this.exists(dir + "/" + fileName))
                this.delete(dir + "/" + fileName);
            name = fileName;
        }
        else {
            let i = -1;
            let ok;
            do {
                i++;
                if (i == 0) {
                    name = fileName;
                }
                else {
                    name = Utils.getNameWithoutExt(fileName) + "_" + i + (Utils.getExt(fileName) != null ? "." + Utils.getExt(fileName) : "");
                }
                ok = !this.exists(dir + "/" + name);
            } while (!ok);
        }
        return name;
    }
    uploadFile(file, dir, isOverwrite) {
        let name = this.uploadFile__getName(file.fileName, dir, isOverwrite);
        let dirDst = this.dir + dir;
        if (!fs.existsSync(dirDst)) {
            fs.mkdirSync(dirDst, {
                mode: 0o777,
                recursive: true
            });
        }
        try {
            fs.writeFileSync(dirDst + "/" + name, file.data);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException(Message.createMessage(this.isCacheDriver, Message.WRITING_FILE_ERROR, dir + "/" + file.fileName));
            }
        }
        return name;
    }
}
DriverLocal.MAX_DEPTH = 20;
//# sourceMappingURL=DriverLocal.js.map