var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as pathUtils from "path";
import { Utils } from "../lib/Utils";
import sharp from "sharp";
import { MessageException } from "../lib/MessageException";
import { Message } from "../model/Message";
import { encode, isBlurhashValid } from "blurhash";
export class CachedFile {
    constructor(fileRelative, driverFiles, driverCache, onLogError) {
        this.fileRelative = fileRelative;
        this.driverFiles = driverFiles;
        this.driverCache = driverCache;
        this.onLogError = onLogError;
        this.cacheFileRelative = "/previews" + fileRelative;
        this.cacheFileJsonRelative = this.cacheFileRelative + ".json";
        this.cacheFilePreviewRelative = this.cacheFileRelative + ".png";
        this.driverCache.makeRootDir();
    }
    delete() {
        if (this.driverCache.exists(this.cacheFileJsonRelative)) {
            this.driverCache.delete(this.cacheFileJsonRelative);
        }
        if (this.driverCache.exists(this.cacheFilePreviewRelative)) {
            this.driverCache.delete(this.cacheFilePreviewRelative);
        }
    }
    getInfo() {
        if (!this.driverCache.exists(this.cacheFileJsonRelative)) {
            try {
                let info = {
                    mtime: this.driverFiles.lastModified(this.fileRelative),
                    size: this.driverFiles.size(this.fileRelative),
                };
                this.writeInfo(info);
            }
            catch (e) {
                if (e instanceof Error) {
                    this.onLogError("Exception while getting image size of " + this.fileRelative + ":\n" +
                        "Name: '" + e.name + "', Message: " + e.message + "\n" + e.stack);
                }
            }
        }
        let content = this.driverCache.get(this.cacheFileJsonRelative).toString();
        try {
            return JSON.parse(content);
        }
        catch (e) {
            if (e instanceof Error) {
                this.onLogError("Unable to parse JSON from file " + this.cacheFileJsonRelative);
                return null;
            }
        }
    }
    writeInfo(info) {
        let dirname = pathUtils.dirname(this.cacheFileJsonRelative);
        if (!this.driverCache.exists(dirname)) {
            this.driverCache.makeDirectory(dirname);
        }
        this.driverCache.put(this.cacheFileJsonRelative, JSON.stringify(info));
    }
    getPreview(previewWidth, previewHeight, contents) {
        return __awaiter(this, void 0, void 0, function* () {
            let cacheFilePreviewRelative = this.cacheFileRelative + ".png";
            if (this.driverCache.exists(cacheFilePreviewRelative)) {
                let info = this.getInfo();
                if (!info ||
                    info["mtime"] !== this.driverFiles.lastModified(this.fileRelative) ||
                    info["size"] !== this.driverFiles.size(this.fileRelative)) {
                    this.driverCache.delete(cacheFilePreviewRelative);
                }
            }
            let resizedImage = null;
            let originalWidth;
            let originalHeight;
            if (!this.driverCache.exists(cacheFilePreviewRelative)) {
                if (Utils.getMimeType(this.fileRelative) === "image/svg+xml") {
                    return {
                        mimeType: "image/svg+xml",
                        path: this.fileRelative,
                        isPathFromCacheFolder: false
                    };
                }
                if (contents === null) {
                    contents = this.driverFiles.get(this.fileRelative);
                }
                let image;
                try {
                    image = yield sharp(contents);
                }
                catch (e) {
                    if (e instanceof Error) {
                        throw new MessageException(Message.createMessage(false, Message.IMAGE_PROCESS_ERROR, null, null, null, e));
                    }
                }
                image = yield image.rotate();
                let metadata = yield image.metadata();
                originalWidth = metadata.width;
                originalHeight = metadata.height;
                if (originalWidth <= 0 || originalHeight <= 0) {
                    throw new MessageException(Message.createMessage(false, Message.IMAGE_PROCESS_ERROR));
                }
                let originalRatio = originalWidth / originalHeight;
                if (previewWidth == null) {
                    previewWidth = Math.max(1, Math.floor(originalRatio * previewHeight));
                }
                else {
                    if (previewHeight === null) {
                        previewHeight = Math.max(1, Math.floor((1 / originalRatio) * previewWidth));
                    }
                }
                let previewRatio = previewWidth / previewHeight;
                if (originalRatio >= previewRatio) {
                    previewHeight = Math.max(1, Math.floor(originalHeight * previewWidth / originalWidth));
                }
                else {
                    previewWidth = Math.max(1, Math.floor(originalWidth * previewHeight / originalHeight));
                }
                image = image.resize(previewWidth, previewHeight);
                resizedImage = yield sharp({
                    create: {
                        width: previewWidth,
                        height: previewHeight,
                        channels: 3,
                        background: { r: 70, g: 20, b: 20 }
                    }
                }).png();
                const rectSize = 20;
                let rectGray1 = yield (yield sharp({
                    create: {
                        width: rectSize,
                        height: rectSize,
                        channels: 3,
                        background: { r: 240, g: 240, b: 240 }
                    }
                })).png().toBuffer();
                let rectGray2 = yield (yield sharp({
                    create: {
                        width: rectSize,
                        height: rectSize,
                        channels: 3,
                        background: { r: 250, g: 250, b: 250 }
                    }
                })).png().toBuffer();
                let overlayOptions = [];
                for (let x = 0; x <= Math.floor(previewWidth / rectSize); x++) {
                    for (let y = 0; y <= Math.floor(previewHeight / rectSize); y++) {
                        overlayOptions.push({
                            input: (((x + y) % 2 === 0) ? rectGray1 : rectGray2),
                            top: y * rectSize,
                            left: x * rectSize,
                        });
                    }
                }
                resizedImage = yield resizedImage.composite([
                    ...overlayOptions,
                    {
                        input: yield image.toBuffer(),
                        top: 0,
                        left: 0,
                    }
                ]);
                let imageContents = yield resizedImage.toFormat("jpg", { quality: 80 }).toBuffer();
                try {
                    this.driverCache.put(cacheFilePreviewRelative, imageContents);
                }
                catch (e) {
                    if (e instanceof Error) {
                        throw new MessageException(Message.createMessage(true, Message.FM_UNABLE_TO_WRITE_PREVIEW_IN_CACHE_DIR, cacheFilePreviewRelative, null, null, e));
                    }
                }
            }
            if (resizedImage == null) {
                try {
                    resizedImage = yield sharp(this.driverCache.get(cacheFilePreviewRelative));
                }
                catch (e) {
                    if (e instanceof Error) {
                        throw new MessageException(Message.createMessage(false, Message.IMAGE_PROCESS_ERROR, null, null, null, e));
                    }
                }
            }
            let blurhash = null;
            try {
                let resizedImageBuffer = yield resizedImage
                    .raw()
                    .ensureAlpha()
                    .toBuffer();
                let metadata = yield resizedImage.metadata();
                blurhash = encode(new Uint8ClampedArray(resizedImageBuffer), metadata.width, metadata.height, 4, 3);
                if (!isBlurhashValid(blurhash))
                    blurhash = null;
            }
            catch (e) {
                if (e instanceof Error) {
                    throw new MessageException(Message.createMessage(false, Message.IMAGE_PROCESS_ERROR, null, null, null, e));
                }
            }
            let cachedImageInfo = this.getInfo();
            if (!!blurhash) {
                cachedImageInfo["blurHash"] = blurhash;
                if (!!originalWidth) {
                    cachedImageInfo["width"] = originalWidth;
                }
                if (!!originalHeight) {
                    cachedImageInfo["height"] = originalHeight;
                }
                this.writeInfo(cachedImageInfo);
            }
            return {
                mimeType: "image/png",
                path: cacheFilePreviewRelative,
                isPathFromCacheFolder: true
            };
        });
    }
}
//# sourceMappingURL=CachedFile.js.map