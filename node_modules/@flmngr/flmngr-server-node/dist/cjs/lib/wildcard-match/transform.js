"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function escapeRegExpChar(char) {
    if (char === '-' ||
        char === '^' ||
        char === '$' ||
        char === '+' ||
        char === '.' ||
        char === '(' ||
        char === ')' ||
        char === '|' ||
        char === '[' ||
        char === ']' ||
        char === '{' ||
        char === '}' ||
        char === '*' ||
        char === '?' ||
        char === '\\') {
        return `\\${char}`;
    }
    else {
        return char;
    }
}
function escapeRegExpString(str) {
    let result = '';
    for (let i = 0; i < str.length; i++) {
        result += escapeRegExpChar(str[i]);
    }
    return result;
}
function transform(pattern, separator = true) {
    if (Array.isArray(pattern)) {
        let regExpPatterns = pattern.map((p) => `^${transform(p, separator)}$`);
        return `(?:${regExpPatterns.join('|')})`;
    }
    let separatorSplitter = '';
    let separatorMatcher = '';
    let wildcard = '.';
    if (separator === true) {
        separatorSplitter = '/';
        separatorMatcher = '[/\\\\]';
        wildcard = '[^/\\\\]';
    }
    else if (separator) {
        separatorSplitter = separator;
        separatorMatcher = escapeRegExpString(separatorSplitter);
        if (separatorMatcher.length > 1) {
            separatorMatcher = `(?:${separatorMatcher})`;
            wildcard = `((?!${separatorMatcher}).)`;
        }
        else {
            wildcard = `[^${separatorMatcher}]`;
        }
    }
    let requiredSeparator = separator ? `${separatorMatcher}+?` : '';
    let optionalSeparator = separator ? `${separatorMatcher}*?` : '';
    let segments = separator ? pattern.split(separatorSplitter) : [pattern];
    let result = '';
    for (let s = 0; s < segments.length; s++) {
        let segment = segments[s];
        let nextSegment = segments[s + 1];
        let currentSeparator = '';
        if (!segment && s > 0) {
            continue;
        }
        if (separator) {
            if (s === segments.length - 1) {
                currentSeparator = optionalSeparator;
            }
            else if (nextSegment !== '**') {
                currentSeparator = requiredSeparator;
            }
            else {
                currentSeparator = '';
            }
        }
        if (separator && segment === '**') {
            if (currentSeparator) {
                result += s === 0 ? '' : currentSeparator;
                result += `(?:${wildcard}*?${currentSeparator})*?`;
            }
            continue;
        }
        for (let c = 0; c < segment.length; c++) {
            let char = segment[c];
            if (char === '\\') {
                if (c < segment.length - 1) {
                    result += escapeRegExpChar(segment[c + 1]);
                    c++;
                }
            }
            else if (char === '?') {
                result += wildcard;
            }
            else if (char === '*') {
                result += `${wildcard}*?`;
            }
            else {
                result += escapeRegExpChar(char);
            }
        }
        result += currentSeparator;
    }
    return result;
}
exports.default = transform;
//# sourceMappingURL=transform.js.map