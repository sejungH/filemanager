"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachedFile = void 0;
const pathUtils = __importStar(require("path"));
const Utils_1 = require("../lib/Utils");
const sharp_1 = __importDefault(require("sharp"));
const MessageException_1 = require("../lib/MessageException");
const Message_1 = require("../model/Message");
const blurhash_1 = require("blurhash");
class CachedFile {
    constructor(fileRelative, driverFiles, driverCache, onLogError) {
        this.fileRelative = fileRelative;
        this.driverFiles = driverFiles;
        this.driverCache = driverCache;
        this.onLogError = onLogError;
        this.cacheFileRelative = "/previews" + fileRelative;
        this.cacheFileJsonRelative = this.cacheFileRelative + ".json";
        this.cacheFilePreviewRelative = this.cacheFileRelative + ".png";
        this.driverCache.makeRootDir();
    }
    delete() {
        if (this.driverCache.exists(this.cacheFileJsonRelative)) {
            this.driverCache.delete(this.cacheFileJsonRelative);
        }
        if (this.driverCache.exists(this.cacheFilePreviewRelative)) {
            this.driverCache.delete(this.cacheFilePreviewRelative);
        }
    }
    getInfo() {
        if (!this.driverCache.exists(this.cacheFileJsonRelative)) {
            try {
                let info = {
                    mtime: this.driverFiles.lastModified(this.fileRelative),
                    size: this.driverFiles.size(this.fileRelative),
                };
                this.writeInfo(info);
            }
            catch (e) {
                if (e instanceof Error) {
                    this.onLogError("Exception while getting image size of " + this.fileRelative + ":\n" +
                        "Name: '" + e.name + "', Message: " + e.message + "\n" + e.stack);
                }
            }
        }
        let content = this.driverCache.get(this.cacheFileJsonRelative).toString();
        try {
            return JSON.parse(content);
        }
        catch (e) {
            if (e instanceof Error) {
                this.onLogError("Unable to parse JSON from file " + this.cacheFileJsonRelative);
                return null;
            }
        }
    }
    writeInfo(info) {
        let dirname = pathUtils.dirname(this.cacheFileJsonRelative);
        if (!this.driverCache.exists(dirname)) {
            this.driverCache.makeDirectory(dirname);
        }
        this.driverCache.put(this.cacheFileJsonRelative, JSON.stringify(info));
    }
    getPreview(previewWidth, previewHeight, contents) {
        return __awaiter(this, void 0, void 0, function* () {
            let cacheFilePreviewRelative = this.cacheFileRelative + ".png";
            if (this.driverCache.exists(cacheFilePreviewRelative)) {
                let info = this.getInfo();
                if (!info ||
                    info["mtime"] !== this.driverFiles.lastModified(this.fileRelative) ||
                    info["size"] !== this.driverFiles.size(this.fileRelative)) {
                    this.driverCache.delete(cacheFilePreviewRelative);
                }
            }
            let resizedImage = null;
            let originalWidth;
            let originalHeight;
            if (!this.driverCache.exists(cacheFilePreviewRelative)) {
                if (Utils_1.Utils.getMimeType(this.fileRelative) === "image/svg+xml") {
                    return {
                        mimeType: "image/svg+xml",
                        path: this.fileRelative,
                        isPathFromCacheFolder: false
                    };
                }
                if (contents === null) {
                    contents = this.driverFiles.get(this.fileRelative);
                }
                let image;
                try {
                    image = yield (0, sharp_1.default)(contents);
                }
                catch (e) {
                    if (e instanceof Error) {
                        throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.IMAGE_PROCESS_ERROR, null, null, null, e));
                    }
                }
                image = yield image.rotate();
                let metadata = yield image.metadata();
                originalWidth = metadata.width;
                originalHeight = metadata.height;
                if (originalWidth <= 0 || originalHeight <= 0) {
                    throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.IMAGE_PROCESS_ERROR));
                }
                let originalRatio = originalWidth / originalHeight;
                if (previewWidth == null) {
                    previewWidth = Math.max(1, Math.floor(originalRatio * previewHeight));
                }
                else {
                    if (previewHeight === null) {
                        previewHeight = Math.max(1, Math.floor((1 / originalRatio) * previewWidth));
                    }
                }
                let previewRatio = previewWidth / previewHeight;
                if (originalRatio >= previewRatio) {
                    previewHeight = Math.max(1, Math.floor(originalHeight * previewWidth / originalWidth));
                }
                else {
                    previewWidth = Math.max(1, Math.floor(originalWidth * previewHeight / originalHeight));
                }
                image = image.resize(previewWidth, previewHeight);
                resizedImage = yield (0, sharp_1.default)({
                    create: {
                        width: previewWidth,
                        height: previewHeight,
                        channels: 3,
                        background: { r: 70, g: 20, b: 20 }
                    }
                }).png();
                const rectSize = 20;
                let rectGray1 = yield (yield (0, sharp_1.default)({
                    create: {
                        width: rectSize,
                        height: rectSize,
                        channels: 3,
                        background: { r: 240, g: 240, b: 240 }
                    }
                })).png().toBuffer();
                let rectGray2 = yield (yield (0, sharp_1.default)({
                    create: {
                        width: rectSize,
                        height: rectSize,
                        channels: 3,
                        background: { r: 250, g: 250, b: 250 }
                    }
                })).png().toBuffer();
                let overlayOptions = [];
                for (let x = 0; x <= Math.floor(previewWidth / rectSize); x++) {
                    for (let y = 0; y <= Math.floor(previewHeight / rectSize); y++) {
                        overlayOptions.push({
                            input: (((x + y) % 2 === 0) ? rectGray1 : rectGray2),
                            top: y * rectSize,
                            left: x * rectSize,
                        });
                    }
                }
                resizedImage = yield resizedImage.composite([
                    ...overlayOptions,
                    {
                        input: yield image.toBuffer(),
                        top: 0,
                        left: 0,
                    }
                ]);
                let imageContents = yield resizedImage.toFormat("jpg", { quality: 80 }).toBuffer();
                try {
                    this.driverCache.put(cacheFilePreviewRelative, imageContents);
                }
                catch (e) {
                    if (e instanceof Error) {
                        throw new MessageException_1.MessageException(Message_1.Message.createMessage(true, Message_1.Message.FM_UNABLE_TO_WRITE_PREVIEW_IN_CACHE_DIR, cacheFilePreviewRelative, null, null, e));
                    }
                }
            }
            if (resizedImage == null) {
                try {
                    resizedImage = yield (0, sharp_1.default)(this.driverCache.get(cacheFilePreviewRelative));
                }
                catch (e) {
                    if (e instanceof Error) {
                        throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.IMAGE_PROCESS_ERROR, null, null, null, e));
                    }
                }
            }
            let blurhash = null;
            try {
                let resizedImageBuffer = yield resizedImage
                    .raw()
                    .ensureAlpha()
                    .toBuffer();
                let metadata = yield resizedImage.metadata();
                blurhash = (0, blurhash_1.encode)(new Uint8ClampedArray(resizedImageBuffer), metadata.width, metadata.height, 4, 3);
                if (!(0, blurhash_1.isBlurhashValid)(blurhash))
                    blurhash = null;
            }
            catch (e) {
                if (e instanceof Error) {
                    throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.IMAGE_PROCESS_ERROR, null, null, null, e));
                }
            }
            let cachedImageInfo = this.getInfo();
            if (!!blurhash) {
                cachedImageInfo["blurHash"] = blurhash;
                if (!!originalWidth) {
                    cachedImageInfo["width"] = originalWidth;
                }
                if (!!originalHeight) {
                    cachedImageInfo["height"] = originalHeight;
                }
                this.writeInfo(cachedImageInfo);
            }
            return {
                mimeType: "image/png",
                path: cacheFilePreviewRelative,
                isPathFromCacheFolder: true
            };
        });
    }
}
exports.CachedFile = CachedFile;
//# sourceMappingURL=CachedFile.js.map