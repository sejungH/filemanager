"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DriverLocal = void 0;
const fs = __importStar(require("fs"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const pathUtils = __importStar(require("path"));
const MessageException_1 = require("../lib/MessageException");
const Message_1 = require("../model/Message");
const Utils_1 = require("../lib/Utils");
class DriverLocal {
    constructor(dir, isCacheDriver = false) {
        this.dir = dir;
        this.isCacheDriver = isCacheDriver;
        this.dir = dir.replace(/\/+$/, '');
        this.makeRootDir();
        try {
            fs.accessSync(this.dir, fs.constants.R_OK);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException_1.MessageException(Message_1.Message.createMessage(this.isCacheDriver, Message_1.Message.FM_DIR_IS_NOT_READABLE, this.dir, null, null, e));
            }
        }
        try {
            fs.accessSync(this.dir, fs.constants.W_OK);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException_1.MessageException(Message_1.Message.createMessage(this.isCacheDriver, Message_1.Message.FM_DIR_IS_NOT_WRITABLE, this.dir, null, null, e));
            }
        }
    }
    setDriverCache(driverCache) {
        this.driverCache = driverCache;
    }
    getDriverName() {
        return "Local";
    }
    getDir() {
        return this.dir;
    }
    size(path) {
        let stats = fs.statSync(this.dir + path);
        return stats.size;
    }
    lastModified(path) {
        let stats = fs.statSync(this.dir + path);
        return stats.mtimeMs;
    }
    makeDirectory(path) {
        if (fs.existsSync(this.dir + path)) {
            let stats = fs.statSync(this.dir + path);
            if (stats.isDirectory())
                return;
        }
        try {
            fs.mkdirSync(this.dir + path, {
                mode: 0o777,
                recursive: true
            });
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException_1.MessageException(Message_1.Message.createMessage(this.isCacheDriver, Message_1.Message.FM_UNABLE_TO_CREATE_DIRECTORY, path, null, null, e));
            }
        }
    }
    getRootDirName() {
        let i = this.dir.lastIndexOf("/");
        if (i === -1) {
            return this.dir;
        }
        return this.dir.substr(i + 1);
    }
    makeRootDir() {
        if (!this.directoryExists("")) {
            this.makeDirectory("");
        }
    }
    allDirectories(dirFrom, maxDepth) {
        let dirs = [];
        let fDir = this.dir + dirFrom;
        if (!fs.existsSync(fDir) ||
            !fs.statSync(fDir).isDirectory()) {
            throw new MessageException_1.MessageException(Message_1.Message.createMessage(this.isCacheDriver, Message_1.Message.FM_ROOT_DIR_DOES_NOT_EXIST));
        }
        let hideDirs = [".cache"];
        let path = "";
        if (dirFrom !== "") {
            path = (pathUtils.basename(this.dir) + '/' + pathUtils.dirname(dirFrom).replace(/\/$/, '')).replace(/\/$/, '');
        }
        this.getDirs__fill(dirs, fDir, hideDirs, path, 0, maxDepth);
        return dirs;
    }
    getDirs__fill(dirs, fDir, hideDirs, path, currDepth, maxDepth) {
        let i = fDir.lastIndexOf("/");
        let dirName;
        if (i > -1) {
            dirName = fDir.substr(i + 1);
        }
        else {
            dirName = fDir;
        }
        dirs.push((path.length > 0 ? ("/" + path) : '') + "/" + dirName);
        let rawDirs;
        try {
            rawDirs = fs.readdirSync(fDir, {
                withFileTypes: true
            }).filter(dirent => dirent.isDirectory()).map(dirent => dirent.name);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException_1.MessageException(Message_1.Message.createMessage(this.isCacheDriver, Message_1.Message.FM_UNABLE_TO_LIST_CHILDREN_IN_DIRECTORY, path, null, null, e));
            }
        }
        for (let dir of rawDirs) {
            dir = dir.replace(fDir + "/", "");
            let isHide = false;
            for (let j = 0; j < hideDirs.length && !isHide; j++) {
                isHide = isHide || Utils_1.Utils.fmmatch(hideDirs[j], dir, false);
            }
            if (fs.statSync(fDir + "/" + dir).isDirectory() && !isHide && currDepth < Math.min(maxDepth, DriverLocal.MAX_DEPTH)) {
                this.getDirs__fill(dirs, fDir + "/" + dir, hideDirs, path + (path.length > 0 ? "/" : "") + dirName, currDepth + 1, maxDepth);
            }
        }
    }
    directories(path) {
        let dirs = [];
        let rawDirs;
        try {
            rawDirs = fs.readdirSync(this.dir + path, {
                withFileTypes: true
            }).filter(dirent => dirent.isDirectory()).map(dirent => dirent.name);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException_1.MessageException(Message_1.Message.createMessage(this.isCacheDriver, Message_1.Message.FM_UNABLE_TO_LIST_CHILDREN_IN_DIRECTORY, path, null, null, e));
            }
        }
        for (const dir of rawDirs) {
            dirs.push(dir.replace(this.dir + path + "/", ""));
        }
        return dirs;
    }
    files(path) {
        let rawFiles;
        try {
            rawFiles = fs.readdirSync(this.dir + path, {
                withFileTypes: true
            }).filter(dirent => !dirent.isDirectory()).map(dirent => dirent.name);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException_1.MessageException(Message_1.Message.createMessage(this.isCacheDriver, Message_1.Message.FM_UNABLE_TO_LIST_CHILDREN_IN_DIRECTORY, path, null, null, e));
            }
        }
        let files = [];
        for (const file of rawFiles) {
            let isFile = false;
            try {
                isFile = fs.statSync(this.dir + path + "/" + file).isFile();
            }
            catch (e) {
            }
            if (isFile) {
                let filename = pathUtils.basename(file);
                files.push({
                    name: filename,
                    mtime: this.lastModified(path + "/" + filename),
                    size: this.size(path + "/" + filename)
                });
            }
        }
        return files;
    }
    move(path, newName) {
        try {
            fs.renameSync(this.dir + path, this.dir + newName);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException_1.MessageException(Message_1.Message.createMessage(this.isCacheDriver, Message_1.Message.FM_UNABLE_TO_RENAME, null, null, null, e));
            }
        }
    }
    getMimeType(path) {
        return Utils_1.Utils.getMimeType(this.dir + path);
    }
    exists(path) {
        return fs.existsSync(this.dir + path);
    }
    directoryExists(path) {
        return fs.existsSync(this.dir + path) && fs.statSync(this.dir + path).isDirectory();
    }
    fileExists(path) {
        return fs.existsSync(this.dir + path) && fs.statSync(this.dir + path).isFile();
    }
    get(path) {
        return fs.readFileSync(this.dir + path);
    }
    put(path, contents) {
        this.makeDirectory(pathUtils.dirname(path));
        fs.writeFileSync(this.dir + path, contents);
    }
    delete(path) {
        if (this.fileExists(path)) {
            try {
                fs.unlinkSync(this.dir + path);
            }
            catch (e) {
                if (e instanceof Error) {
                    throw new MessageException_1.MessageException(Message_1.Message.createMessage(this.isCacheDriver, Message_1.Message.UNABLE_TO_DELETE_FILE, path, null, null, e));
                }
            }
        }
        else if (this.directoryExists(path)) {
            try {
                this.deleteFolderRecursiveSync(this.dir + path);
            }
            catch (e) {
                if (e instanceof Error) {
                    throw new MessageException_1.MessageException(Message_1.Message.createMessage(this.isCacheDriver, Message_1.Message.FM_UNABLE_TO_DELETE_DIRECTORY, null, null, null, e));
                }
            }
        }
    }
    deleteFolderRecursiveSync(directoryPath) {
        if (fs.existsSync(directoryPath)) {
            fs.readdirSync(directoryPath).forEach((file, index) => {
                const curPath = pathUtils.join(directoryPath, file);
                if (fs.lstatSync(curPath).isDirectory()) {
                    this.deleteFolderRecursiveSync(curPath);
                }
                else {
                    fs.unlinkSync(curPath);
                }
            });
            fs.rmdirSync(directoryPath);
        }
    }
    ;
    readStream(path) {
        return fs.createReadStream(this.dir + path);
    }
    copyFile(pathSrc, pathDst) {
        try {
            fs.copyFileSync(this.dir + pathSrc, this.dir + pathDst);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException_1.MessageException(Message_1.Message.createMessage(this.isCacheDriver, Message_1.Message.FM_ERROR_ON_COPYING_FILES));
            }
        }
    }
    copyDirectory(src, dst) {
        try {
            fs_extra_1.default.copySync(this.dir + src, this.dir + dst);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException_1.MessageException(Message_1.Message.createMessage(this.isCacheDriver, Message_1.Message.FM_ERROR_ON_COPYING_FILES, null, null, null, e));
            }
        }
    }
    uploadFile__getName(fileName, dir, isOverwrite) {
        let name = null;
        if (isOverwrite) {
            if (this.exists(dir + "/" + fileName))
                this.delete(dir + "/" + fileName);
            name = fileName;
        }
        else {
            let i = -1;
            let ok;
            do {
                i++;
                if (i == 0) {
                    name = fileName;
                }
                else {
                    name = Utils_1.Utils.getNameWithoutExt(fileName) + "_" + i + (Utils_1.Utils.getExt(fileName) != null ? "." + Utils_1.Utils.getExt(fileName) : "");
                }
                ok = !this.exists(dir + "/" + name);
            } while (!ok);
        }
        return name;
    }
    uploadFile(file, dir, isOverwrite) {
        let name = this.uploadFile__getName(file.fileName, dir, isOverwrite);
        let dirDst = this.dir + dir;
        if (!fs.existsSync(dirDst)) {
            fs.mkdirSync(dirDst, {
                mode: 0o777,
                recursive: true
            });
        }
        try {
            fs.writeFileSync(dirDst + "/" + name, file.data);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new MessageException_1.MessageException(Message_1.Message.createMessage(this.isCacheDriver, Message_1.Message.WRITING_FILE_ERROR, dir + "/" + file.fileName));
            }
        }
        return name;
    }
}
exports.DriverLocal = DriverLocal;
DriverLocal.MAX_DEPTH = 20;
//# sourceMappingURL=DriverLocal.js.map