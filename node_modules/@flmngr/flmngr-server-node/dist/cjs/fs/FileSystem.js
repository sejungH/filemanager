"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileSystem = void 0;
const DriverLocal_1 = require("./DriverLocal");
const MessageException_1 = require("../lib/MessageException");
const Message_1 = require("../model/Message");
const FMDir_1 = require("../model/FMDir");
const pathUtils = __importStar(require("path"));
const Utils_1 = require("../lib/Utils");
const CachedFile_1 = require("./CachedFile");
const sharp_1 = __importDefault(require("sharp"));
class FileSystem {
    constructor(config, embedPreviews, onLogError) {
        this.embedPreviews = embedPreviews;
        this.onLogError = onLogError;
        let dirCache = config.dirCache ? config.dirCache : (!config.dirFiles ? null : config.dirFiles + "/.cache");
        this.driverFiles = new DriverLocal_1.DriverLocal(config.dirFiles);
        this.driverCache = new DriverLocal_1.DriverLocal(dirCache, true);
        this.driverFiles.setDriverCache(this.driverCache);
    }
    getRelativePath(path) {
        if (path.indexOf("..") > -1) {
            throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.FM_DIR_NAME_CONTAINS_INVALID_SYMBOLS));
        }
        if (path.indexOf("/") !== 0) {
            path = "/" + path;
        }
        let rootDirName = this.driverFiles.getRootDirName();
        if (path === "/Files") {
            path = "/" + rootDirName;
        }
        else {
            if (path.indexOf("/Files/") === 0) {
                path = "/" + rootDirName + "/" + path.substr(7);
            }
        }
        if (path.indexOf("/" + rootDirName) !== 0) {
            throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.FM_DIR_NAME_INCORRECT_ROOT));
        }
        return path.substr(("/" + rootDirName).length);
    }
    reqGetDirs(request) {
        let hideDirs = request.getParameterStringArray("hideDirs", []);
        let dirFrom = request.getParameterString("fromDir", "");
        dirFrom = "/" + dirFrom.replace(/^\/+/, "").replace(/\/+$/, "");
        if (dirFrom === "/")
            dirFrom = "";
        if (dirFrom.indexOf("..") > -1) {
            throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.FM_DIR_NAME_CONTAINS_INVALID_SYMBOLS));
        }
        let maxDepth = request.getParameterNumber("maxDepth", 99);
        let dirs = [];
        hideDirs.push(".cache");
        let dirRoot = this.driverFiles.getRootDirName();
        let i = dirRoot.lastIndexOf("/");
        if (i > -1) {
            dirRoot = dirRoot.substr(i + 1);
        }
        dirRoot += dirFrom;
        let addFilesPrefix = dirRoot === "";
        let dirsStr = this.driverFiles.allDirectories(dirFrom, maxDepth);
        for (const dirStr of dirsStr) {
            let dirArr = dirStr.split(/\//);
            if (addFilesPrefix) {
                dirArr.unshift("Files");
            }
            let filled = dirArr.length <= maxDepth + 1;
            dirs.push(new FMDir_1.FMDir(dirArr[dirArr.length - 1], dirArr.slice(0, dirArr.length - 1).join("/"), filled).getJSON());
        }
        return dirs;
    }
    reqGetFilesPaged(request) {
        let dirPath = request.getParameterString("dir");
        let maxFiles = request.getParameterNumber("maxFiles", 0);
        if (maxFiles < 1) {
            throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.MALFORMED_REQUEST));
        }
        let alwaysInclude = request.getParameterStringArray("alwaysInclude", []);
        let lastFile = request.getParameterString("lastFile", null);
        let lastIndex = request.getParameterNumber("lastIndex", null);
        let whiteList = request.getParameterStringArray("whiteList", []);
        let blackList = request.getParameterStringArray("blackList", []);
        let filter = request.getParameterString("filter", "*");
        let orderBy = request.getParameterString("orderBy");
        let orderAsc = request.getParameterString("orderAsc");
        let formatIds = request.getParameterStringArray("formatIds");
        let formatSuffixes = request.getParameterStringArray("formatSuffixes", []);
        dirPath = this.getRelativePath(dirPath);
        let now = new Date().getTime();
        let start = now;
        let files = [];
        let formatFiles = {};
        for (const formatId of formatIds) {
            formatFiles[formatId] = {};
        }
        let fFiles = this.driverFiles.files(dirPath);
        now = this.profile("Scan dir", now);
        for (const file of fFiles) {
            let format = null;
            let name = Utils_1.Utils.getNameWithoutExt(file.name);
            if (Utils_1.Utils.isImage(file.name)) {
                for (let i = 0; i < formatIds.length; i++) {
                    let isFormatFile = name.endsWith(formatSuffixes[i]);
                    if (isFormatFile) {
                        format = formatIds[i];
                        name = name.substr(0, name.length - formatSuffixes[i].length);
                        break;
                    }
                }
            }
            let ext = Utils_1.Utils.getExt(file.name);
            if (ext !== null) {
                name = name + "." + ext;
            }
            if (format === null) {
                switch (orderBy) {
                    case "date":
                        files.push([
                            file.mtime,
                            file.name,
                            file.size,
                            file.name
                        ]);
                        break;
                    case "size":
                        files.push([
                            file.size,
                            file.name,
                            file.mtime,
                            file.name
                        ]);
                        break;
                    case "name":
                    default:
                        files.push([
                            file.name,
                            file.mtime,
                            file.size,
                            file.name
                        ]);
                        break;
                }
            }
            else {
                formatFiles[format][name] = file.name;
            }
        }
        now = this.profile("Fill image formats", now);
        if (whiteList.length > 0) {
            for (let i = files.length - 1; i >= 0; i--) {
                let fileArr = files[i];
                let file = fileArr[3];
                let isMatch = false;
                for (const mask of whiteList) {
                    if (Utils_1.Utils.fmmatch(mask, file, true)) {
                        isMatch = true;
                    }
                }
                if (!isMatch) {
                    files.splice(i, 1);
                    for (const format in formatFiles) {
                        let formatFilesCurr = formatFiles[format];
                        if (file in formatFilesCurr) {
                            delete formatFilesCurr[file];
                        }
                    }
                }
            }
        }
        now = this.profile("White list", now);
        for (let i = files.length - 1; i >= 0; i--) {
            let fileArr = files[i];
            let file = fileArr[3];
            let isMatch = false;
            for (const mask of blackList) {
                if (Utils_1.Utils.fmmatch(mask, file, true)) {
                    isMatch = true;
                }
            }
            if (isMatch) {
                files.splice(i, 1);
                for (const format in formatFiles) {
                    let formatFilesCurr = formatFiles[format];
                    if (file in formatFilesCurr)
                        delete formatFilesCurr[file];
                }
            }
        }
        let countTotal = files.length;
        now = this.profile("Black list", now);
        for (let i = files.length - 1; i >= 0; i--) {
            let fileArr = files[i];
            let file = fileArr[3];
            let isMatch = Utils_1.Utils.fmmatch(filter, file, false);
            if (!isMatch) {
                files.splice(i, 1);
                for (const format in formatFiles) {
                    let formatFilesCurr = formatFiles[format];
                    if (file in formatFilesCurr) {
                        delete formatFilesCurr[file];
                    }
                }
            }
        }
        let countFiltered = files.length;
        now = this.profile("Filter", now);
        files = files.sort((arr1, arr2) => {
            for (let i = 0; i < 3; i++) {
                if (typeof arr1[i] === "string") {
                    let v = Utils_1.Utils.strnatcmp(arr1[i], arr2[i]);
                    if (v !== 0) {
                        return v;
                    }
                }
                else {
                    if (arr1[i] > arr2[i]) {
                        return 1;
                    }
                    if (arr1[i] < arr2[i]) {
                        return -1;
                    }
                }
            }
            return 0;
        });
        let fileNames = files.map(f => f[3]);
        if (orderAsc.toLowerCase() !== "true") {
            fileNames = fileNames.reverse();
        }
        now = this.profile("Sorting", now);
        let startIndex = 0;
        if (!!lastIndex) {
            startIndex = lastIndex + 1;
        }
        if (!!lastFile) {
            let i = fileNames.indexOf(lastFile);
            if (i > -1) {
                startIndex = i + 1;
            }
        }
        let isEnd = startIndex + maxFiles >= fileNames.length;
        if (startIndex > 0 || maxFiles < fileNames.length) {
            for (let i = alwaysInclude.length - 1; i >= 0; i--) {
                let index = fileNames.indexOf(alwaysInclude[i]);
                if (index === -1) {
                    alwaysInclude.splice(i, 1);
                }
                else {
                    fileNames.splice(index, 1);
                }
            }
            fileNames = fileNames.slice(startIndex, maxFiles);
            for (let i = alwaysInclude.length - 1; i >= 0; i--)
                fileNames.unshift(alwaysInclude[i]);
        }
        for (let i = 0; i < fileNames.length; i++) {
            if (!(alwaysInclude.indexOf(fileNames[i]) > -1 ||
                (i >= startIndex && i < startIndex + maxFiles))) {
                fileNames[i] = null;
            }
        }
        fileNames = fileNames.filter(f => f !== null);
        now = this.profile("Page slice", now);
        let resultFiles = [];
        for (const fileName of fileNames) {
            let resultFile = this.getFileStructure(dirPath, fileName);
            for (const formatId of formatIds) {
                if (fileName in formatFiles[formatId]) {
                    let formatFileName = formatFiles[formatId][fileName];
                    let formatFile = this.getFileStructure(dirPath, formatFileName);
                    resultFile["formats"][formatId] = formatFile;
                }
            }
            resultFiles.push(resultFile);
        }
        now = this.profile("Create output list", now);
        this.profile("Total", start);
        return {
            files: resultFiles,
            countTotal: countTotal,
            countFiltered: countFiltered,
            isEnd: isEnd
        };
    }
    getFileStructure(dirPath, fileName) {
        let cachedImageInfo = this.getCachedImageInfo(dirPath + "/" + fileName);
        let resultFile = {
            name: fileName,
            size: cachedImageInfo.size,
            timestamp: cachedImageInfo.mtime
        };
        if (Utils_1.Utils.isImage(fileName)) {
            resultFile.width = cachedImageInfo.width || null;
            resultFile.height = cachedImageInfo.height || null;
            resultFile.blurHash = cachedImageInfo.blurHash || null;
            resultFile.formats = [];
        }
        return resultFile;
    }
    reqGetImagePreview(request) {
        return __awaiter(this, void 0, void 0, function* () {
            let filePath = request.getParameterString("f");
            filePath = this.getRelativePath(filePath);
            let result = yield this.getCachedImagePreview(filePath, null);
            return {
                mimeType: result.mimeType,
                readStream: (!result.isPathFromCacheFolder ? this.driverFiles : this.driverCache).readStream(result.path)
            };
        });
    }
    reqGetImagePreviewAndResolution(request) {
        return __awaiter(this, void 0, void 0, function* () {
            let filePath = request.getParameterString("f");
            let width = request.getParameterString("width", null);
            let height = request.getParameterString("height", null);
            filePath = this.getRelativePath(filePath);
            let previewAndResolution = yield this.getCachedImagePreviewAndResolution(filePath, null);
            return {
                width: previewAndResolution.width,
                height: previewAndResolution.height,
                preview: previewAndResolution.path != null ? ("data:" + previewAndResolution.mimeType + ";base64," +
                    (!previewAndResolution.isPathFromCacheFolder ? this.driverFiles : this.driverCache).get(previewAndResolution.path).toString("base64")) : null
            };
        });
    }
    reqCopyDir(request) {
        let dirPath = request.getParameterString("d");
        let newPath = request.getParameterString("n");
        dirPath = this.getRelativePath(dirPath);
        newPath = this.getRelativePath(newPath);
        this.driverFiles.copyDirectory(dirPath, newPath);
    }
    reqCopyFiles(request) {
        let files = request.getParameterString("fs", null);
        if (!files || files === "") {
            throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.MALFORMED_REQUEST));
        }
        let newPath = request.getParameterString("n");
        let filesPaths = files.split(/\|/g);
        for (let i = 0; i < filesPaths.length; i++) {
            filesPaths[i] = this.getRelativePath(filesPaths[i]);
        }
        newPath = this.getRelativePath(newPath);
        for (let i = 0; i < filesPaths.length; i++) {
            this.driverFiles.copyFile(filesPaths[i], newPath.replace(/\/+$/, '') + "/" + pathUtils.basename(filesPaths[i]));
        }
    }
    getCachedFile(filePath) {
        return new CachedFile_1.CachedFile(filePath, this.driverFiles, this.driverCache, this.onLogError);
    }
    getCachedImageInfo(filePath) {
        let start = new Date().getTime();
        let result = this.getCachedFile(filePath).getInfo();
        this.profile("getCachedImageInfo: " + filePath, start);
        return result;
    }
    getCachedImagePreview(filePath, contents) {
        return __awaiter(this, void 0, void 0, function* () {
            let start = new Date().getTime();
            let result = yield this.getCachedFile(filePath).getPreview(FileSystem.PREVIEW_WIDTH, FileSystem.PREVIEW_HEIGHT, contents);
            this.profile("getCachedImagePreview: " + filePath, start);
            return result;
        });
    }
    getCachedImagePreviewAndResolution(filePath, contents) {
        return __awaiter(this, void 0, void 0, function* () {
            let start = new Date().getTime();
            let cachedFile = this.getCachedFile(filePath);
            let preview = yield cachedFile.getPreview(FileSystem.PREVIEW_WIDTH, FileSystem.PREVIEW_HEIGHT, contents);
            let info = cachedFile.getInfo();
            this.profile("getCachedImagePreviewAndResolution: " + filePath, start);
            return Object.assign(Object.assign({}, preview), { width: info.width, height: info.height });
        });
    }
    reqCreateDir(request) {
        let dirPath = request.getParameterString("d");
        let name = request.getParameterString("n");
        dirPath = this.getRelativePath(dirPath);
        if (!name || name.length === 0) {
            throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.MALFORMED_REQUEST));
        }
        if (name.indexOf("/") > -1) {
            throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.FM_DIR_NAME_CONTAINS_INVALID_SYMBOLS));
        }
        this.driverFiles.makeDirectory(dirPath + "/" + name);
    }
    reqDeleteDir(request) {
        let dirPath = request.getParameterString("d");
        dirPath = this.getRelativePath(dirPath);
        this.driverFiles.delete(dirPath);
    }
    reqMove(request) {
        let path = request.getParameterString("d");
        let newPath = request.getParameterString("n");
        path = this.getRelativePath(path);
        newPath = this.getRelativePath(newPath);
        this.driverFiles.move(path, newPath + "/" + pathUtils.basename(path));
    }
    reqRename(request) {
        let path = request.getParameterString("d", null);
        if (!path)
            path = request.getParameterString("f", null);
        let newName = request.getParameterString("n");
        if (newName.indexOf("/") > -1) {
            throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.FM_DIR_NAME_CONTAINS_INVALID_SYMBOLS));
        }
        path = this.getRelativePath(path);
        this.driverFiles.move(path, pathUtils.dirname(path).replace(/\/+$/, '') + "/" + newName);
    }
    reqMoveFiles(request) {
        let filePathsStr = request.getParameterString("fs", null);
        if (!filePathsStr) {
            throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.MALFORMED_REQUEST));
        }
        let filesPaths = filePathsStr.split(/\|/);
        let newPath = request.getParameterString("n");
        filesPaths = filesPaths.map(filePath => this.getRelativePath(filePath));
        newPath = this.getRelativePath(newPath);
        for (const filePath of filesPaths) {
            let index = filePath.lastIndexOf("/");
            let name = index === -1 ? filePath : filePath.substr(index + 1);
            this.driverFiles.move(filePath, newPath + "/" + name);
        }
    }
    updateFormatsAndClearCachePreviewForFile(filePath, formatSuffixes) {
        let fullPaths = [];
        let index = filePath.lastIndexOf(".");
        let fullPathPrefix;
        if (index > -1) {
            fullPathPrefix = filePath.substr(0, index);
        }
        else {
            fullPathPrefix = filePath;
        }
        if (!!formatSuffixes && Array.isArray(formatSuffixes)) {
            for (const formatSuffix of formatSuffixes) {
                let exts = ["png", "jpg", "jpeg", "webp"];
                for (const ext of exts) {
                    fullPaths.push(fullPathPrefix + formatSuffix + "." + ext);
                }
            }
        }
        let cachedFile = this.getCachedFile(filePath);
        cachedFile.delete();
        for (const fullPath of fullPaths) {
            if (this.driverFiles.fileExists(fullPath)) {
                this.driverFiles.delete(fullPath);
            }
        }
    }
    reqDeleteFiles(request) {
        let filePathsStr = request.getParameterString("fs", null);
        if (!filePathsStr) {
            throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.MALFORMED_REQUEST));
        }
        let filesPaths = filePathsStr.split(/\|/);
        let formatSuffixes = request.getParameterStringArray("formatSuffixes");
        filesPaths = filesPaths.map(filePath => this.getRelativePath(filePath));
        for (const filePath of filesPaths) {
            this.driverFiles.delete(filePath);
            this.updateFormatsAndClearCachePreviewForFile(filePath, formatSuffixes);
        }
    }
    reqGetFilesSpecified(request) {
        let files = request.getParameterStringArray("files");
        let result = [];
        for (let file of files) {
            file = "/" + file;
            if (file.indexOf("..") > -1) {
                throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.FM_DIR_NAME_CONTAINS_INVALID_SYMBOLS));
            }
            if (this.driverFiles.fileExists(file)) {
                result.push({
                    dir: pathUtils.dirname(file),
                    file: this.getFileStructure(pathUtils.dirname(file), pathUtils.basename(file))
                });
            }
        }
        return result;
    }
    reqResizeFile(request) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.reqResizeFile2(request)).url;
        });
    }
    reqResizeFile2(request) {
        return __awaiter(this, void 0, void 0, function* () {
            let filePath = request.getParameterString("f");
            let newFileNameWithoutExt = request.getParameterString("n");
            let width = request.getParameterNumber("mw");
            let height = request.getParameterNumber("mh");
            let mode = request.getParameterString("mode");
            if (filePath.indexOf("..") > -1) {
                throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.FM_DIR_NAME_CONTAINS_INVALID_SYMBOLS));
            }
            if (newFileNameWithoutExt.indexOf("..") > -1 ||
                newFileNameWithoutExt.indexOf("/") > -1 ||
                newFileNameWithoutExt.indexOf("\\") > -1) {
                throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.FM_DIR_NAME_CONTAINS_INVALID_SYMBOLS));
            }
            let index = filePath.lastIndexOf("/");
            let oldFileNameWithExt = filePath.substr(index + 1);
            let newExt = "png";
            let oldExt = Utils_1.Utils.getExt(filePath).toLowerCase();
            if (oldExt === "svg") {
                return {
                    url: filePath,
                    width: -1,
                    height: -1
                };
            }
            if (oldExt === "jpg" || oldExt === "jpeg") {
                newExt = "jpg";
            }
            if (oldExt === "webp") {
                newExt = "webp";
            }
            let dstPath = filePath.substr(0, index) + "/" + newFileNameWithoutExt + "." + newExt;
            if (Utils_1.Utils.getNameWithoutExt(dstPath) === Utils_1.Utils.getNameWithoutExt(filePath)) {
                dstPath = filePath;
            }
            let isDstPathExists = this.driverFiles.fileExists(dstPath);
            if (mode === 'IF_EXISTS' && !isDstPathExists) {
                throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.FM_NOT_ERROR_NOT_NEEDED_TO_UPDATE));
            }
            if (mode === 'DO_NOT_UPDATE' && isDstPathExists) {
                let info = yield this.getCachedImagePreviewAndResolution(dstPath, this.driverFiles.get(dstPath));
                return {
                    url: dstPath,
                    width: info.width,
                    height: info.height
                };
            }
            let contents = this.driverFiles.get(filePath);
            let image;
            try {
                image = yield (0, sharp_1.default)(contents);
            }
            catch (e) {
                if (e instanceof Error) {
                    throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.IMAGE_PROCESS_ERROR, null, null, null, e));
                }
            }
            image = yield image.rotate();
            yield this.getCachedImagePreview(filePath, contents);
            let imageInfo = this.getCachedImageInfo(filePath);
            let originalWidth = imageInfo["width"];
            let originalHeight = imageInfo["height"];
            let needToFitWidth = originalWidth > width && width > 0;
            let needToFitHeight = originalHeight > height && height > 0;
            if (needToFitWidth && needToFitHeight) {
                if (width / originalWidth < height / originalHeight) {
                    needToFitHeight = false;
                }
                else {
                    needToFitWidth = false;
                }
            }
            if (!needToFitWidth && !needToFitHeight) {
                if (!isDstPathExists ||
                    newFileNameWithoutExt + "." + oldExt === oldFileNameWithExt) {
                    let info = yield this.getCachedImagePreviewAndResolution(filePath, this.driverFiles.get(filePath));
                    return {
                        url: filePath,
                        width: info.width,
                        height: info.height
                    };
                }
                else {
                    width = originalWidth;
                    height = originalHeight;
                }
            }
            let ratio;
            if (needToFitWidth) {
                ratio = width / originalWidth;
                height = Math.max(1, Math.floor(originalHeight * ratio));
            }
            else if (needToFitHeight) {
                ratio = height / originalHeight;
                width = Math.max(1, Math.floor(originalWidth * ratio));
            }
            let resizedImage = image.resize(width, height);
            this.driverFiles.put(dstPath, yield resizedImage.toFormat(newExt).toBuffer());
            return {
                url: dstPath,
                width: width,
                height: height
            };
        });
    }
    reqGetImageOriginal(request) {
        let filePath = request.getParameterString("f");
        filePath = this.getRelativePath(filePath);
        let mimeType = Utils_1.Utils.getMimeType(filePath);
        if (mimeType == null) {
            throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.FM_FILE_IS_NOT_IMAGE));
        }
        let readStream = this.driverFiles.readStream(filePath);
        return {
            mimeType: mimeType,
            readStream: readStream
        };
    }
    reqGetVersion(req, framework) {
        return {
            version: "6",
            build: "3",
            language: "node",
            framework: framework || "custom",
            storage: this.driverFiles.getDriverName(),
            dirFiles: this.driverFiles.getDir(),
            dirCache: this.driverCache.getDir(),
        };
    }
    reqUpload(request) {
        let dir = request.getParameterString("dir", "/");
        dir = this.getRelativePath("/" + this.driverFiles.getRootDirName() + dir);
        let isOverwrite = request.getParameterString("mode", "AUTORENAME") === "OVERWRITE";
        let file = request.getParameterFile("file");
        if (!file) {
            throw new MessageException_1.MessageException(Message_1.Message.createMessage(false, Message_1.Message.FILES_NOT_SET));
        }
        let name = this.driverFiles.uploadFile(file, dir, isOverwrite);
        if (isOverwrite) {
            let formatSuffixes = request.getParameterStringArray("formatSuffixes", null);
            this.updateFormatsAndClearCachePreviewForFile(dir + "/" + name, formatSuffixes);
        }
        let resultFile = this.getFileStructure(dir, name);
        return {
            file: resultFile
        };
    }
    profile(text, start) {
        let now = new Date().getTime();
        let time = now - start;
        return now;
    }
}
exports.FileSystem = FileSystem;
FileSystem.PREVIEW_WIDTH = 159;
FileSystem.PREVIEW_HEIGHT = 139;
//# sourceMappingURL=FileSystem.js.map